#!/usr/bin/env node

const canboatjs = require('../index')
const Parser = require('../index').FromPgn
const { parseCanId } = require('../lib/canId')
const { parseActisense } = require('../lib/stringMsg')

const { toPgn } = require('../lib/toPgn')
const { getPlainPGNs, binToActisense } = require('../lib/utilities')
const { encodeCanId } = require('../lib/canId')

const argv = require('minimist')(process.argv.slice(2), {
  boolean: ['test', 'log-output'],
  string: ['src'],
  alias: { h: 'help' }
})

if ( argv['help'] ) {
  console.error(`Usage: ${process.argv[0]} [options] candevice

Options:
  --src <src>    use src for all messages
  --log-output   log messages sent
  --test         don't connect or send any data
  -h, --help     output usage information`)
  process.exit(1)
}

if ( argv['_'].length === 0 ) {
  console.error('Please specify a device')
  process.exit(1)
}

const canDevice = argv['_'][0]
const srcArg = argv.src
const logOut = argv['log-output']
const test = argv.test

let channel

if ( !test ) {
  const socketcan = require('socketcan')
  channel = socketcan.createRawChannel(canDevice);
  
  channel.addListener('onStopped', (msg) => {
    console.error('socketcan stopped')
  })
  
  channel.start()
}

var readline = require('readline')
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
})

var input = []

rl.on('line', function (line) {
  if ( line.length === 0 ) {
    return
  }
  
  let msg =  line[0] === '{'  ? JSON.parse(line) : line

  if ( typeof msg === 'string' ) {
    var split = msg.split(',')
    if ( srcArg !== undefined ) {
      split[3] = srcArg
    }
    msg = split.join(',')
  } else {
    if ( msg.prio === undefined ) {
      msg.prio = 3
    }
    if ( msg.dst === undefined ) {
      msg.dst = 255
    }
    if ( srcArg !== undefined ) {
      msg.src = srcArg
    }
    if ( msg.src === undefined ) {
      msg.src = 100
    }
  }

  var pgn, canid, buffer
  if ( typeof msg === 'object' ) {
    canid = encodeCanId(msg)
    buffer = toPgn(msg)
    if ( buffer === undefined ) {
      console.error('invalid input: %s', line)
      return
    }
    pgn = msg
  } else {
    pgn = parseActisense(msg)

    if ( isNaN(pgn.prio) || isNaN(pgn.pgn) || isNaN(pgn.dst) || isNaN(pgn.src) ) {
      console.error('invalid input: ' + line)
      return
    }
    
    canid = encodeCanId(pgn)
    buffer = pgn.data
  }
  
  pgn.timestamp = new Date().toISOString()
  
  if ( buffer.length > 8 || pgn.pgn == 126720 ) {
    var pgns = getPlainPGNs(buffer)
    pgns.forEach(pbuffer => {
      if ( !test ) {
        channel.send({id: canid, ext:true, data: pbuffer})
      }
      if ( logOut ) {
        console.log(binToActisense(pgn, pbuffer, pbuffer.length))
      }
    })                    
  } else {
    if ( !test ) {
      channel.send({id: canid, ext:true, data: buffer})
    }
    if ( logOut ) {
      console.log(binToActisense(pgn, buffer, buffer.length))
    }
  }
})
